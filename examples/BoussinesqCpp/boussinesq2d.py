import logging
import struct
import subprocess
from typing import Any
import numpy as np
from messaging import Message
from messaging import MessageType
from messaging import TwoWayPipe
from messaging import exit_msg
from messaging import trigger_save_msg
from pytams.fmodel import ForwardModelBaseClass

_logger = logging.getLogger(__name__)


class Boussinesq2DModelCpp(ForwardModelBaseClass):
    """A forward model for the 2D Boussinesq C++ model.

    This variant of the Boussinesq model uses a C++ executable to
    advance the model instead of a Python implementation. This demonstrates one way of
    coupling TAMS to existing external software.
    """

    def _init_model(self, m_id: int, params: dict[Any, Any]) -> None:
        """Concrete class specific initialization.

        Args:
            m_id: the model instance unique identifier
            params: an optional dict containing parameters
        """
        # Keep the model id around
        self._m_id = m_id

        # Parse parameters
        subparms = params.get("model", {})
        self._M = subparms.get("size_M", 40)  # Horizontals
        self._N = subparms.get("size_N", 80)  # Verticals
        self._K = subparms.get("K", 4)  # Number of forcing modes = 2*K
        self._eps = subparms.get("epsilon", 0.05)  # Noise level
        self._exec = subparms.get("exec", None)
        self._exec_cmd = [
            self._exec,
            "-M",
            str(self._M),
            "-N",
            str(self._N),
            "-K",
            str(self._K),
            "--eps",
            str(self._eps),
            "--pipe_id",
            str(m_id),
        ]

        # A handle to the C++ subprocess and the twoway pipe
        self._proc = None
        self._pipe = None

        # Initialize random number generator
        # If deterministic run, set seed from the traj id
        if subparms["deterministic"]:
            self._rng = np.random.default_rng(m_id)
        else:
            self._rng = np.random.default_rng()

        self._db_path = self._workdir.parents[1]
        if not self._workdir.exists():
            self._workdir.mkdir()

        # The state is a path to a npy file on disk
        self._state = subparms.get("init_state", None)

    def get_current_state(self) -> Any:
        """Return the current state of the model.

        Note that the return type is left to the concrete model definition.
        """
        return self._state

    def get_last_statefile(self) -> str | None:
        """Return the last statefile of the model."""
        if not self._proc:
            return None

        self._pipe.post_message(Message(MessageType.GETSTATE))

        ret = self._pipe.get_message()
        if ret.mtype != MessageType.DONE:
            err_msg = "Unable to obtain the last statefile generated by the C++ code"
            _logger.error(err_msg)
            raise RuntimeError

        return ret.data.decode("utf-8")

    def set_current_state(self, state: Any) -> None:
        """Set the model state.

        And transfer it to the C++ process if opened

        Args:
            state: the new state
        """
        self._state = state
        if not self._proc:
            return

        self._pipe.post_message(Message(MessageType.SETSTATE, data=state.encode("utf-8")))

        ret = self._pipe.get_message()
        if ret.mtype != MessageType.DONE:
            err_msg = "Unable to set the state of the C++ code"
            _logger.error(err_msg)
            raise RuntimeError

    def _advance(self, _step: int, _time: float, dt: float, noise: Any, need_end_state: bool) -> float:
        """Advance the model.

        Args:
            step: the current step counter
            time: the starting time of the advance call
            dt: the time step size over which to advance
            noise: the noise to be used in the model step
            need_end_state: whether the step end state is needed

        Return:
            Some model will not do exactly dt (e.g. sub-stepping) return the actual dt
        """
        if not self._proc:
            # Initialize the C++ process and the twoway pipe
            self._proc = subprocess.Popen(self._exec_cmd)

            self._pipe = TwoWayPipe(str(self._m_id))
            self._pipe.open()

            # Send the workdir
            self._pipe.post_message(Message(MessageType.SETWORKDIR, data=self._workdir.as_posix().encode("utf-8")))

            # Set the initial state
            self.set_current_state(self._state)

        if need_end_state:
            self._pipe.post_message(trigger_save_msg)

        self._pipe.post_message(Message(MessageType.ONESTOCHSTEP, data=noise.tobytes()))
        ret = self._pipe.get_message()
        if ret.mtype != MessageType.DONE:
            err_msg = "Unable to access the score from the C++ code"
            _logger.error(err_msg)
            raise RuntimeError

        self._score = struct.unpack("d", ret.data)[0]

        if need_end_state:
            self._state = self.get_last_statefile()
        else:
            self._state = None

        return dt

    def _clear_model(self) -> None:
        if self._proc:
            self._pipe.post_message(exit_msg)
            self._proc.wait()
            self._proc = None
            self._pipe.close()
            self._pipe = None

    def score(self) -> float:
        """Compute the score function.

        The current score function is a nomalized distance between the ON
        and OFF states in the stream function space (specifically the
        mean streamfunction in the southern ocean).

        Return:
            the score
        """
        if not self._proc:
            return 0.0

        self._pipe.post_message(Message(MessageType.GETSCORE))
        ret = self._pipe.get_message()
        if ret.mtype != MessageType.DONE:
            err_msg = "Unable to access the score from the C++ code"
            _logger.error(err_msg)
            raise RuntimeError
        return struct.unpack("d", ret.data)[0]

    def make_noise(self) -> Any:
        """Return the model's latest noise increment.

        Note that the noise type is left to the concrete model definition.

        Returns:
            The model next noise increment
        """
        return self._rng.normal(0, 1, size=(2 * self._K))

    @classmethod
    def name(cls) -> str:
        """Return the model name."""
        return "2DBoussinesqModelCpp"

